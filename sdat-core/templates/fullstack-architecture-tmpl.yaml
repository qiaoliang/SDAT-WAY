template:
  id: fullstack-architecture-template-v2
  name: 全栈架构文档
  version: 2.0
  output:
    format: markdown
    filename: docs/architecture.md
    title: "{{project_name}} 全栈架构文档"

workflow:
  mode: interactive
  elicitation: advanced-elicitation

sections:
  - id: introduction
    title: 介绍
    instruction: |
      如果可用，请审查任何提供的相关文档以收集所有相关上下文。至少，您应该访问 docs/prd.md 和 docs/front-end-spec.md。向用户请求任何您需要但无法找到的文档。此模板创建一个统一架构，涵盖后端和前端问题，以指导 AI 驱动的全栈开发。
    elicit: true
    content: |
      本文档概述了 {{project_name}} 的完整全栈架构，包括后端系统、前端实现及其集成。它作为 AI 驱动的开发的单一事实来源，确保整个技术栈的一致性。

      这种方法结合了传统上分离的后端和前端架构文档，简化了现代全栈应用程序的开发流程，其中这些关注点越来越相互交织。
    sections:
      - id: starter-template
        title: 启动模板或现有项目
        instruction: |
          在开始架构设计之前，检查项目是否基于任何启动模板或现有代码库:

          1. Review the PRD and other documents for mentions of:
          - 全栈启动模板 (例如，T3 Stack, MEAN/MERN 启动器, Django + React 模板)
          - 单体仓库模板 (例如，Nx, Turborepo 启动器)
          - 平台特定启动器 (例如，Vercel 模板, AWS Amplify 启动器)
          - 正在扩展或克隆的现有项目

          2. If starter templates or existing projects are mentioned:
          - 请求用户提供访问权限 (链接, 仓库或文件)
          - 分析以理解预配置的选择和约束
          - 记录任何已经做出的架构决策
          - 识别可以修改的和必须保留的

          3. If no starter is mentioned but this is greenfield:
          - 根据技术偏好建议适当的全栈启动器
          - 考虑平台特定选项 (Vercel, AWS 等)
          - 让用户决定是否使用

          4. 记录决策和任何它施加的约束

          5. 如果 none，则状态 "N/A - Greenfield project"
      - id: changelog
        title: 变更日志
        type: table
        columns: [Date, Version, Description, Author]
        instruction: 跟踪文档版本和变更

  - id: high-level-architecture
    title: 高级别架构
    instruction: 本节包含多个子部分，建立基础。呈现所有子部分，然后征求对完整部分的反馈。
    elicit: true
    sections:
      - id: technical-summary
        title: 技术摘要
        instruction: |
          提供全面的概述 (4-6 句话) 涵盖:
          - 整体架构风格与部署方式
          - 前端框架和后端技术选择
          - 前端和后端的关键集成点
          - 基础设施平台和服务
          - 此架构如何实现 PRD 目标
      - id: platform-infrastructure
        title: 平台和基础设施选择
        instruction: |
          基于 PRD 要求和技术假设，做出平台推荐:

          1. 考虑常见模式 (不是详尽列表，使用您自己的最佳判断并搜索网络以获取新兴趋势):
          - **Vercel + Supabase**: For rapid development with Next.js, built-in auth/storage
          - **AWS Full Stack**: 企业级规模与 Lambda, API Gateway, S3, Cognito
          - **Azure**: 企业级 Microsoft 环境或 .NET 生态系统
          - **Google Cloud**: 机器学习/人工智能密集型应用程序或 Google 生态系统集成

          2. 呈现 2-3 个可行的选项，并清楚地列出优缺点
          3. 做出有理有据的推荐
          4. 获得明确的用户确认

          记录所选平台和关键服务
        template: |
          **Platform:** {{selected_platform}}
          **Key Services:** {{core_services_list}}
          **Deployment Host and Regions:** {{regions}}
      - id: repository-structure
        title: 仓库结构
        instruction: |
          基于 PRD 要求和平台选择，定义仓库方法，如果不确定，请解释您的理由或向用户提问:

          1. 对于现代全栈应用程序，通常首选 monorepo
          2. 考虑工具 (Nx, Turborepo, Lerna, npm workspaces)
          3. 定义 package/app 边界
          4. 计划前端和后端之间的共享代码
        template: |
          **Structure:** {{repo_structure_choice}}
          **Monorepo Tool:** {{monorepo_tool_if_applicable}}
          **Package Organization:** {{package_strategy}}
      - id: architecture-diagram
        title: 高级别架构图
        type: mermaid
        mermaid_type: graph
        instruction: |
          创建一个 Mermaid 图表，显示完整的系统架构，包括:
          - 用户入口 (web, mobile)
          - 前端应用程序部署
          - API 层 (REST/GraphQL)
          - 后端服务
          - 数据库和存储
          - 外部集成
          - CDN 和缓存层

          使用适当的图表类型以清晰。
      - id: architectural-patterns
        title: 架构模式
        instruction: |
          列出将指导前端和后端开发的模式。包括模式:
          - 整体架构 (例如，Jamstack, Serverless, Microservices)
          - 前端模式 (例如，组件化, 状态管理)
          - 后端模式 (例如，仓库, CQRS, 事件驱动)
          - 集成模式 (例如，BFF, API Gateway)

          对于每个模式，提供推荐和理由。
        repeatable: true
        template: "- **{{pattern_name}}:** {{pattern_description}} - _Rationale:_ {{rationale}}"
        examples:
          - "**Jamstack 架构:** 静态站点生成与无服务器 API - _理由:_ 内容密集型应用程序的最佳性能和可扩展性"
          - "**组件化 UI:** 可重用 React 组件与 TypeScript - _理由:_ 大型代码库的维护性和类型安全"
          - "**仓库模式:** 抽象数据访问逻辑 - _理由:_ 启用测试和未来数据库迁移灵活性"
          - "**API 网关模式:** 所有 API 调用的单个入口点 - _理由:_ 集中式身份验证、速率限制和监控"

  - id: tech-stack
    title: 技术栈
    instruction: |
      这是整个项目的最终技术选择。与用户合作完成所有选择。此表是单一事实来源 - 所有开发必须使用这些确切版本。

      关键领域:
      - 前端和后端语言/框架
      - 数据库和缓存
      - 身份验证和授权
      - API 方法
      - 前端和后端测试工具
      - 构建和部署工具
      - 监控和日志

      渲染后，立即征求反馈。
    elicit: true
    sections:
      - id: tech-stack-table
        title: 技术栈表
        type: table
        columns: [Category, Technology, Version, Purpose, Rationale]
        rows:
          - ["前端语言", "{{fe_language}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["前端框架", "{{fe_framework}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["UI 组件库", "{{ui_library}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["State Management", "{{state_mgmt}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["后端语言", "{{be_language}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["后端框架", "{{be_framework}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["API 风格", "{{api_style}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["Database", "{{database}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["Cache", "{{cache}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["文件存储", "{{storage}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["Authentication", "{{auth}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["前端测试", "{{fe_test}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["后端测试", "{{be_test}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["E2E 测试", "{{e2e_test}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["构建工具", "{{build_tool}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["打包工具", "{{bundler}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["IaC 工具", "{{iac_tool}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["CI/CD", "{{cicd}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["监控", "{{monitoring}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["日志", "{{logging}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]
          - ["CSS 框架", "{{css_framework}}", "{{version}}", "{{purpose}}", "{{why_chosen}}"]

  - id: data-models
    title: 数据模型
    instruction: |
      定义将由前端和后端共享的核心数据模型/实体:

      1. 审查 PRD 要求并识别关键业务实体
      2. 对于每个模型，解释其目的和关系
      3. 包括关键属性和数据类型
      4. 显示模型之间的关系
      5. 创建 TypeScript 接口，可以共享
      6. 与用户讨论设计决策

      在移动到数据库模式之前，创建一个清晰的概要模型。
    elicit: true
    repeatable: true
    sections:
      - id: model
        title: "{{model_name}}"
        template: |
          **目的:** {{model_purpose}}

          **关键属性:**
          - {{attribute_1}}: {{type_1}} - {{description_1}}
          - {{attribute_2}}: {{type_2}} - {{description_2}}
          - {{attribute_3}}: {{type_3}} - {{description_3}}
        sections:
          - id: typescript-interface
            title: TypeScript 接口
            type: code
            language: typescript
            template: "{{model_interface}}"
          - id: relationships
            title: 关系
            type: bullet-list
            template: "- {{relationship}}"

  - id: api-spec
    title: API 规范
    instruction: |
      基于技术栈中选择的技术风格:

      1. 如果 REST API，创建一个 OpenAPI 3.0 规范
      2. 如果 GraphQL，提供 GraphQL 模式
      3. 如果 tRPC，显示路由定义
      4. 包括所有端点来自 epics/stories
      5. 基于数据模型定义请求/响应模式
      6. 记录身份验证要求
      7. 包括示例请求/响应

      使用适当的格式用于所选的 API 风格。如果没有 API (例如，静态站点)，跳过此部分。
    elicit: true
    sections:
      - id: rest-api
        title: REST API 规范
        condition: API 风格是 REST
        type: code
        language: yaml
        template: |
          openapi: 3.0.0
          info:
            title: {{api_title}}
            version: {{api_version}}
            description: {{api_description}}
          servers:
            - url: {{server_url}}
              description: {{server_description}}
      - id: graphql-api
        title: GraphQL 模式
        condition: API 风格是 GraphQL
        type: code
        language: graphql
        template: "{{graphql_schema}}"
      - id: trpc-api
        title: tRPC 路由定义
        condition: API 风格是 tRPC
        type: code
        language: typescript
        template: "{{trpc_routers}}"

  - id: components
    title: 组件
    instruction: |
      基于上面的架构模式、技术栈和数据模型:

      1. 识别全栈中的主要逻辑组件/服务
      2. 定义组件之间的清晰边界和接口
      3. 对于每个组件，指定:
      - 主要责任
      - 关键接口/API
      - 其他组件的依赖
      - 基于技术栈选择的技术细节

      在需要时创建组件图表
    elicit: true
    sections:
      - id: component-list
        repeatable: true
        title: "{{component_name}}"
        template: |
          **Responsibility:** {{component_description}}

          **Key Interfaces:**
          - {{interface_1}}
          - {{interface_2}}

          **Dependencies:** {{dependencies}}

          **Technology Stack:** {{component_tech_details}}
      - id: component-diagrams
        title: 组件图表
        type: mermaid
        instruction: |
          创建 Mermaid 图表以可视化组件关系。选项:
          - C4 容器图表用于高级视图
          - 组件图表用于详细内部结构
          - 序列图表用于复杂交互
          选择最合适的以清晰。

  - id: external-apis
    title: 外部 API
    condition: 项目需要外部 API 集成
    instruction: |
      对于每个外部服务集成:

      1. 基于 PRD 要求和组件设计识别需要的 API
      2. 如果文档 URL 未知，请用户提供具体信息
      3. 记录身份验证方法和安全考虑
      4. 列出将使用的特定端点
      5. 注意任何速率限制或使用约束

      如果没有外部 API 需要，明确说明并跳过下一节。
    elicit: true
    repeatable: true
    sections:
      - id: api
        title: "{{api_name}} API"
        template: |
          - **目的:** {{api_purpose}}
          - **文档:** {{api_docs_url}}
          - **基础 URL(s):** {{api_base_url}}
          - **Authentication:** {{auth_method}}
          - **Rate Limits:** {{rate_limits}}

          **关键端点:**
          - `{{method}} {{endpoint_path}}` - {{endpoint_purpose}}

          **Integration Notes:** {{integration_considerations}}

  - id: core-workflows
    title: 核心工作流
    type: mermaid
    mermaid_type: sequence
    instruction: |
      使用序列图说明关键系统工作流:

      1. 从 PRD 识别关键用户旅程
      2. 显示包括外部 API 的组件交互
      3. 包括前端和后端流程
      4. 包括错误处理路径
      5. 记录异步操作
      6. 根据需要创建高级和详细图表

      专注于澄清架构决策或复杂交互的工作流。
    elicit: true

  - id: database-schema
    title: 数据库schema
    instruction: |
      将概念数据模型转换为具体的数据库模式:

      1. 使用技术栈中选择的数据库类型
      2. 使用适当的符号创建模式定义
      3. 包括索引、约束和关系
      4. 考虑性能和可扩展性
      5. 对于 NoSQL，显示文档结构

      以适合数据库类型的格式呈现模式 (SQL DDL, JSON schema, etc.)
    elicit: true

  - id: frontend-architecture
    title: 前端架构
    instruction: 定义前端特定架构细节。在每个子部分之后，注意如果用户想要在继续之前细化。
    elicit: true
    sections:
      - id: component-architecture
        title: 组件架构
        instruction: 基于所选框架定义组件组织和模式。
        sections:
          - id: component-organization
            title: 组件组织
            type: code
            language: text
            template: "{{component_structure}}"
          - id: component-template
            title: 组件模板
            type: code
            language: typescript
            template: "{{component_template}}"
      - id: state-management
        title: 状态管理架构
        instruction: 基于所选解决方案详细说明状态管理方法。
        sections:
          - id: state-structure
            title: 状态结构
            type: code
            language: typescript
            template: "{{state_structure}}"
          - id: state-patterns
            title: 状态管理模式
            type: bullet-list
            template: "- {{pattern}}"
      - id: routing-architecture
        title: 路由架构
        instruction: 基于框架选择定义路由结构。
        sections:
          - id: route-organization
            title: 路由组织
            type: code
            language: text
            template: "{{route_structure}}"
          - id: protected-routes
            title: 受保护的路由模式
            type: code
            language: typescript
            template: "{{protected_route_example}}"
      - id: frontend-services
        title: 前端服务层
        instruction: 定义前端如何与后端通信。
        sections:
          - id: api-client-setup
            title: API 客户端设置
            type: code
            language: typescript
            template: "{{api_client_setup}}"
          - id: service-example
            title: 服务示例
            type: code
            language: typescript
            template: "{{service_example}}"

  - id: backend-architecture
    title: 后端架构
    instruction: 定义后端特定架构细节。考虑无服务器与传统服务器方法。
    elicit: true
    sections:
      - id: service-architecture
        title: 服务架构
        instruction: 基于平台选择，定义服务组织。
        sections:
          - id: serverless-architecture
            condition: 选择无服务器架构
            sections:
              - id: function-organization
                title: 函数组织
                type: code
                language: text
                template: "{{function_structure}}"
              - id: function-template
                title: 函数模板
                type: code
                language: typescript
                template: "{{function_template}}"
          - id: traditional-server
            condition: 选择传统服务器架构
            sections:
              - id: controller-organization
                title: 控制器/路由组织
                type: code
                language: text
                template: "{{controller_structure}}"
              - id: controller-template
                title: 控制器模板
                type: code
                language: typescript
                template: "{{controller_template}}"
      - id: database-architecture
        title: 数据库架构
        instruction: 定义数据库模式和访问模式。
        sections:
          - id: schema-design
            title: 模式设计
            type: code
            language: sql
            template: "{{database_schema}}"
          - id: data-access-layer
            title: 数据访问层
            type: code
            language: typescript
            template: "{{repository_pattern}}"
      - id: auth-architecture
        title: 身份验证和授权
        instruction: 定义身份验证实现细节。
        sections:
          - id: auth-flow
            title: 身份验证流程
            type: mermaid
            mermaid_type: sequence
            template: "{{auth_flow_diagram}}"
          - id: auth-middleware
            title: 中间件/守卫
            type: code
            language: typescript
            template: "{{auth_middleware}}"

  - id: unified-project-structure
    title: 统一项目结构
    instruction: 创建一个 monorepo 结构，同时容纳前端和后端。根据所选工具和框架进行调整。
    elicit: true
    type: code
    language: plaintext
    examples:
    - |
      {{project-name}}/
      ├── .github/                    # CI/CD 工作流
      │   └── workflows/
      │       ├── ci.yaml
      │       └── deploy.yaml
      ├── apps/                       # 应用包
      │   ├── web/                    # 前端应用
      │   │   ├── src/
      │   │   │   ├── components/     # UI 组件
      │   │   │   ├── pages/          # 页面组件/路由
      │   │   │   ├── hooks/          # 自定义 React 钩子
      │   │   │   ├── services/       # API 客户端服务
      │   │   │   ├── stores/         # 状态管理
      │   │   │   ├── styles/         # 全局样式/主题
      │   │   │   └── utils/          # 前端工具
      │   │   ├── public/             # 静态资产
      │   │   ├── tests/              # 前端测试
      │   │   └── package.json
      │   └── api/                    # 后端应用
      │       ├── src/
      │       │   ├── routes/         # API 路由/控制器
      │       │   ├── services/       # 业务逻辑
      │       │   ├── models/         # 数据模型
      │       │   ├── middleware/     # Express/API 中间件
      │       │   ├── utils/          # 后端工具
      │       │   └── {{serverless_or_server_entry}}
      │       ├── tests/              # Backend tests
      │       └── package.json
      ├── packages/                   # 共享包
      │   ├── shared/                 # 共享类型/工具
      │   │   ├── src/
      │   │   │   ├── types/          # TypeScript 接口
      │   │   │   ├── constants/      # 共享常量
      │   │   │   └── utils/          # 共享工具
      │   │   └── package.json
      │   ├── ui/                     # 共享 UI 组件
      │   │   ├── src/
      │   │   └── package.json
      │   └── config/                 # 共享配置
      │       ├── eslint/
      │       ├── typescript/
      │       └── jest/
      ├── infrastructure/             # IaC 定义
      │   └── {{iac_structure}}
      ├── scripts/                    # 构建/部署脚本
      ├── docs/                       # 文档
      │   ├── prd.md
      │   ├── front-end-spec.md
      │   └── fullstack-architecture.md
      ├── .env.example                # 环境模板
      ├── package.json                # Root package.json
      ├── {{monorepo_config}}         # Monorepo 配置
      └── README.md

  - id: development-workflow
    title: 开发工作流
    instruction: 定义全栈应用的开发设置和工作流。
    elicit: true
    sections:
      - id: local-setup
        title: 本地开发设置
        sections:
          - id: prerequisites
            title: 先决条件
            type: code
            language: bash
            template: "{{prerequisites_commands}}"
          - id: initial-setup
            title: 初始设置
            type: code
            language: bash
            template: "{{setup_commands}}"
          - id: dev-commands
            title: 开发命令
            type: code
            language: bash
            template: |
              # 启动所有服务
              {{start_all_command}}

              # 只启动前端
              {{start_frontend_command}}

              # 只启动后端
              {{start_backend_command}}

              # 运行测试
              {{test_commands}}
      - id: environment-config
        title: 环境配置
        sections:
          - id: env-vars
            title: 必需的环境变量
            type: code
            language: bash
            template: |
              # Frontend (.env.local)
              {{frontend_env_vars}}

              # Backend (.env)
              {{backend_env_vars}}

              # Shared
              {{shared_env_vars}}

  - id: deployment-architecture
    title: 部署架构
    instruction: 基于平台选择定义部署策略。
    elicit: true
    sections:
      - id: deployment-strategy
        title: 部署策略
        template: |
          **前端部署:**
          - **平台:** {{frontend_deploy_platform}}
          - **构建命令:** {{frontend_build_command}}
          - **输出目录:** {{frontend_output_dir}}
          - **CDN/Edge:** {{cdn_strategy}}

          **后端部署:**
          - **平台:** {{backend_deploy_platform}}
          - **构建命令:** {{backend_build_command}}
          - **部署方法:** {{deployment_method}}
      - id: cicd-pipeline
        title: CI/CD 流水线
        type: code
        language: yaml
        template: "{{cicd_pipeline_config}}"
      - id: environments
        title: 环境
        type: table
        columns: [Environment, Frontend URL, Backend URL, Purpose]
        rows:
          - ["Development", "{{dev_fe_url}}", "{{dev_be_url}}", "Local development"]
          - ["Staging", "{{staging_fe_url}}", "{{staging_be_url}}", "Pre-production testing"]
          - ["Production", "{{prod_fe_url}}", "{{prod_be_url}}", "Live environment"]

  - id: security-performance
    title: 安全和性能
    instruction: 定义全栈应用的安全和性能考虑。
    elicit: true
    sections:
      - id: security-requirements
        title: 安全要求
        template: |
          **前端安全:**
          - CSP 头: {{csp_policy}}
          - XSS 预防: {{xss_strategy}}
          - 安全存储: {{storage_strategy}}

          **后端安全:**
          - 输入验证: {{validation_approach}}
          - 速率限制: {{rate_limit_config}}
          - CORS 策略: {{cors_config}}

          **身份验证安全:**
          - 令牌存储: {{token_strategy}}
          - 会话管理: {{session_approach}}
          - 密码策略: {{password_requirements}}
      - id: performance-optimization
        title: 性能优化
        template: |
          **前端性能:**
          - bundle 大小目标: {{bundle_size}}
          - 加载策略: {{loading_approach}}
          - 缓存策略: {{fe_cache_strategy}}

          **后端性能:**
          - 响应时间目标: {{response_target}}
          - 数据库优化: {{db_optimization}}
          - 缓存策略: {{be_cache_strategy}}

  - id: testing-strategy
    title: 测试策略
    instruction: 定义全栈应用的综合测试方法。
    elicit: true
    sections:
      - id: testing-pyramid
        title: 测试金字塔
        type: code
        language: text
        template: |
                  端到端测试
                 /        \
            前端集成测试  后端集成测试
               /            \
          前端单元测试     后端单元测试
      - id: test-organization
        title: 测试组织
        sections:
          - id: frontend-tests
            title: 前端测试
            type: code
            language: text
            template: "{{frontend_test_structure}}"
          - id: backend-tests
            title: 后端测试
            type: code
            language: text
            template: "{{backend_test_structure}}"
          - id: e2e-tests
            title: 端到端测试
            type: code
            language: text
            template: "{{e2e_test_structure}}"
      - id: test-examples
        title: 测试示例
        sections:
          - id: frontend-test
            title: 前端组件测试
            type: code
            language: typescript
            template: "{{frontend_test_example}}"
          - id: backend-test
            title: 后端 API 测试
            type: code
            language: typescript
            template: "{{backend_test_example}}"
          - id: e2e-test
            title: 端到端测试
            type: code
            language: typescript
            template: "{{e2e_test_example}}"

  - id: coding-standards
    title: 编码标准
    instruction: 定义 AI 代理的最小但关键的标准。仅关注防止常见错误的项目特定规则。这些将由开发代理使用。
    elicit: true
    sections:
      - id: critical-rules
        title: 关键全栈规则
        repeatable: true
        template: "- **{{rule_name}}:** {{rule_description}}"
        examples:
          - "**类型共享:** 始终在 packages/shared 中定义类型并从那里导入"
          - "**API 调用:** 不要直接进行 HTTP 调用 - 使用服务层"
          - "**环境变量:** 仅通过 config 对象访问，不要直接访问 process.env"
          - "**错误处理:** 所有 API 路由必须使用标准错误处理"
          - "**状态更新:** 不要直接修改状态 - 使用适当的状态管理模式"
      - id: naming-conventions
        title: 命名约定
        type: table
        columns: [Element, Frontend, Backend, Example]
        rows:
          - ["组件", "PascalCase", "-", "`UserProfile.tsx`"]
          - ["钩子", "camelCase with 'use'", "-", "`useAuth.ts`"]
          - ["API 路由", "-", "kebab-case", "`/api/user-profile`"]
          - ["数据库表", "-", "snake_case", "`user_profiles`"]

  - id: error-handling
    title: 错误处理策略
    instruction: 定义前端和后端的一致错误处理。
    elicit: true
    sections:
      - id: error-flow
        title: 错误流
        type: mermaid
        mermaid_type: sequence
        template: "{{error_flow_diagram}}"
      - id: error-format
        title: 错误响应格式
        type: code
        language: typescript
        template: |
          interface ApiError {
            error: {
              code: string;
              message: string;
              details?: Record<string, any>;
              timestamp: string;
              requestId: string;
            };
          }
      - id: frontend-error-handling
        title: 前端错误处理
        type: code
        language: typescript
        template: "{{frontend_error_handler}}"
      - id: backend-error-handling
        title: 后端错误处理
        type: code
        language: typescript
        template: "{{backend_error_handler}}"

  - id: monitoring
    title: 监控和可观测性
    instruction: 定义全栈应用的监控策略。
    elicit: true
    sections:
      - id: monitoring-stack
        title: 监控堆栈
        template: |
          - **前端监控:** {{frontend_monitoring}}
          - **后端监控:** {{backend_monitoring}}
          - **错误跟踪:** {{error_tracking}}
          - **性能监控:** {{perf_monitoring}}
      - id: key-metrics
        title: 关键指标
        template: |
          **前端指标:**
          - Core Web Vitals
          - JavaScript 错误
          - API 响应时间
          - 用户交互

          **后端指标:**
          - Request rate请求率
          - Error rate错误率
          - Response time响应时间
          - Database query performance数据库查询性能

  - id: checklist-results
    title: 清单结果报告
    instruction: 在运行清单之前，请提供输出完整架构文档的选项。一旦用户确认，执行架构师清单并在此处填充结果。